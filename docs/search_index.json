[
["index.html", "Computational graphics structures for geo-spatial data Chapter 1 About this 1.1 Description and objectives", " Computational graphics structures for geo-spatial data Michael Sumner 2019-09-03 Chapter 1 About this This workshop is for R users familiar with spatial workflows looking to work with computational graphics tools, 3D visualization and modelling frameworks. This resource is published online at: https://mdsumner.github.io/geo-comp-graphics-oghub/. The source code to create this resource is available on Github at: https://github.com/mdsumner/geo-comp-graphics-oghub/ 1.1 Description and objectives There is no definitive standard for computational-graphics data structures, although these are used in a variety of R packages. Modern geo-spatial data types are now largely defined with by a non-topology model where the geometry is stored as an atomic single object with no recorded knowledge of its relation to other geometries. This works well in a single-table database context, where the properties of features and their geometry are stored side by side, and records can be completely independent of each other. This model is used for vector data, and requires a strong distinction to raster data where geometry is kept implicit for efficiency reasons. It is very inefficient to store a polygon rectangle for every pixel in a raster, and so a spatial raster image is one of the simplest forms of a mesh. We simply store the value of every pixel, information about the storage of values (grid orientation, data layout) and the space covered (bounding box) by that grid, in a particular coordinate system. This hard distinction between vector and raster leaves out the wonderful world of meshes, which can be seen as a more general form for spatial data in any form in multidimensional spaces. The rgl package provides the most fundamental mesh data types but has typically been suited only for expert-users. This workshop introduces the core concepts for data meshes and their relationships to vector and raster data for 3D visualization and modelling frameworks. We will introduce existing tools for conversion from geo-spatial data for visualization and use of mesh-based tools. Installation instructions: https://mdsumner.github.io/geo-comp-graphics-oghub/getting-set-up.html Datasets in use: two_polys a tiny polygon data set with two simple polygon neighbours mesh_polys and delaunay_polys two mesh counterparts of two_polys with slightly different properties world_topo, world_mesh, a simple global elevation raster and its mesh counterpart bluemarble0 a simple RGB image of the world "],
["getting-set-up.html", "Chapter 2 Getting Set Up", " Chapter 2 Getting Set Up NOTE: throughout these pages are calls to the rglwidget() function, which is necessary for putting these 3D plots into view for this document and when using RStudio Server. For normal installations of R you can avoid running this function. We suggest use of the package remotes which will avoid re-installing a package if the latest version is already installed. if (!requireNamespace(&quot;remotes&quot;)) install.packages(&quot;remotes&quot;) pkgs &lt;- c(&quot;ceramic&quot;, &quot;colourvalues&quot;, &quot;dplyr&quot;, &quot;quadmesh&quot;, &quot;raster&quot;, &quot;rgl&quot;, &quot;rgdal&quot;, &quot;scales&quot;, &quot;sf&quot;, &quot;sfdct&quot;, &quot;spex&quot;, &quot;tidyr&quot;, &quot;viridis&quot;) remotes::install_cran(pkgs) In-development packages from Github: remotes::install_github(c(&quot;hypertidy/silicate&quot;, &quot;hypertidy/anglr&quot;, &quot;AustralianAntarcticDivision/raadtools&quot;)) Obtain some extra data sets that will be used in this session. download.file(&quot;https://github.com/mdsumner/geo-comp-graphics-oghub/raw/master/data-raw/geo-comp-graphics.Rdata&quot;, &quot;geo-comp-graphics.Rdata&quot;, mode = &quot;wb&quot;) load(&quot;geo-comp-graphics.Rdata&quot;) ## a world image (Blue Marble) bm_url &lt;- &quot;https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg&quot; bm_file &lt;- basename(bm_url) if (!file.exists(bm_file)) download.file(bm_url, bm_file) Miscellaneous functions used to build the examples. colpal &lt;- function(n = 26, drop = 5) sf::sf.colors(n)[-seq_len(drop)] plot_values &lt;- function(x) { raster::plot(x, axes = FALSE, main = &quot;value&quot;, box = FALSE, col = colpal()); text(coordinates(x), label = values(x)) raster::plot(extent(x), add = TRUE) } plot_cells &lt;- function(x) { raster::plot(x, axes = FALSE, main = &quot;cell&quot;, legend = FALSE, box = FALSE, col = colpal()); raster::plot(extent(x), add = TRUE) text(coordinates(x), label = sprintf(&quot;[%i]&quot;, seq_len(ncell(x))), cex = 0.8) } plot_edges &lt;- function(x, main = &quot;&quot;) { sc &lt;- silicate::SC(spex::polygonize(x)) e &lt;- silicate::sc_edge(sc) v &lt;- silicate::sc_vertex(sc) x0 &lt;- e %&gt;% dplyr::inner_join(v, c(&quot;.vx0&quot; = &quot;vertex_&quot;)) x1 &lt;- e %&gt;% dplyr::inner_join(v, c(&quot;.vx1&quot; = &quot;vertex_&quot;)) plot(rbind(x0, x1)[c(&quot;x_&quot;, &quot;y_&quot;)], asp = 1, type = &quot;n&quot;, axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot;, main = main) graphics::segments(x0$x_, x0$y_, x1$x_, x1$y_, lty = 2) } "],
["d-and-mesh-forms-of-spatial-data.html", "Chapter 3 3D and mesh forms of spatial data 3.1 Questions 3.2 What is a mesh? 3.3 Geospatial data 3.4 Primitives 3.5 A raster is a mesh (implicitly) 3.6 Summary", " Chapter 3 3D and mesh forms of spatial data 3.1 Questions What are meshes and topology? what is the relationship of meshes to geospatial raster/vector data? 3.2 What is a mesh? Key ideas! Topology: the shape of things and their relationships. Geometry: the where of things. Indexing: the link between topology and geometry. Traditional spatial data tends to confuse topology and geometry. These concepts motivate my interest in these ideas. Lossless reprojection Topology fixes Tracks and point clouds Visualization Topology vs. geometry This line has 1-dimensional topology depicted in 3-dimensional geometry and the triangle has 2-dimensional topology depicted in 3-dimensional geometry. library(rgl) clear3d() #p3 &lt;- mfrow3d(1, 2, sharedMouse = TRUE) (geometry &lt;- cbind(x = c(0, 0.5, 1), y = c(0, 0.5, 1), z = c(0, 0, 0.8))) ## x y z ## [1,] 0.0 0.0 0.0 ## [2,] 0.5 0.5 0.0 ## [3,] 1.0 1.0 0.8 (topology1 &lt;- rbind(.v0 = c(1, 2), .v1 = c(2, 3))) ## [,1] [,2] ## .v0 1 2 ## .v1 2 3 lines3d(geometry[t(topology1), ], lwd = 3, col = &quot;firebrick&quot;) material3d(col = &quot;black&quot;) axis3d(&quot;x&quot;) axis3d(&quot;y&quot;) axis3d(&quot;z&quot;) title3d(xlab = &quot;x&quot;, ylab = &quot;y&quot;, zlab = &quot;z&quot;) quads3d(cbind(c(0, 1, 1, 0), c(0, 0, 1, 1), c(0, 0, 0, 0) - 0.01), col=&quot;gray&quot;) rglwidget() #next3d() clear3d() (topology2 &lt;- rbind(.v0 = c(1, 2, 1), .v1 = c(2, 3, 1))) ## [,1] [,2] [,3] ## .v0 1 2 1 ## .v1 2 3 1 triangles3d(geometry[t(topology2), ], col = &quot;firebrick&quot;) material3d(col = &quot;black&quot;) axis3d(&quot;x&quot;) axis3d(&quot;y&quot;) axis3d(&quot;z&quot;) title3d(xlab = &quot;x&quot;, ylab = &quot;y&quot;, zlab = &quot;z&quot;) quads3d(cbind(c(0, 1, 1, 0), c(0, 0, 1, 1), c(0, 0, 0, 0)), col=&quot;gray&quot;) rglwidget() clear3d() 3.3 Geospatial data raster vector These are traditionally kept separate, but in computer graphics the distinction starts to disappear. What is a raster? A layer of neighbouring rectangles? Or a continuous fields between points? (Lots of ways to infer the field, including this very poor one). What is a polygon? A series of grouped paths? What’s in the middle? ## Warning in st_centroid.sf(tri): st_centroid assumes attributes are constant ## over geometries of x The fill we see in traditional 2D graphics is a trick!!. Search: it’s not what you draw it’s what you not draw ~Paul Murrell Technically the trick comes in two types, either the even-odd or winding rule, and this trick is not part of this workshop. The graphics engine uses this rule to draw a pixel if it has been encircled an even or odd number of times, or using a rule about in which direction it was encircled. It happens deep in the graphics. Where it does matter is for the concept of orientation, and 3D graphics do care about the direction that triangles are wound (consider that reversing the direction is like flipping the triangle in place in terms of how some algorithms behave …). What’s the fill? In 3D, and to fill our polygons properly as data - we need primitives. 3.4 Primitives Terminology alert! (This is my working definition of primitive for this topic, not everyone agrees.) Point - a single coordinate is a 0-dimensional primitive (vertex, coordinate) Line - a line segment between two coordinates is a 1-dimensional primitive (edge, segment) Triangle - a triangle joining three coordinates is 2-dimensional primitive Quad - a four-sided shape (not as core-primitive as a triangle, but commonly used) Topology is not geometry (This is topological dimension. Every one of these types of shape can be depicted within a geometric space that is equal to or higher than the topological dimension.) We will have a matrix of vertices and a matrix of primitive indices. Quads and triangles are generally called faces, line segments are alternatively called edges. All are primitives in computer graphics, but we’ll also see the term finite element used. Topology can be 3D (tetrahedron) - imagine volumetric fill versus planar faces bounding a volume. Geometry can be 4D, X, Y, Z, T - or any dimensionality we need. To fill our polygon we need triangles. ## Warning in st_cast.sf(sfdct::ct_triangulate(minimal_mesh, a = 0.01, D = ## TRUE)): repeating attributes for all sub-geometries for which they may not ## be constant Note that if we turn off the border, we don’t notice the difference. No tricky winding or even-odd rule to worry about, but we have lost our boundary around each distinct shape - we could find them by finding edges within a shape that are not shared by two triangles … plot(tri, border = NA, col = rainbow(10)) ## Warning in plot.sf(tri, border = NA, col = rainbow(10)): col is not of ## length 1 or nrow(x): colors will be recycled; use pal to specify a color ## palette Raster and vector are not a strong distinction when it comes to meshes A raster is a very simple version of a mesh. When we store a raster we need the equivalent of number of columns and rows the extent in the coordinate system used (xmin, xmax, ymin, ymax) the coordinate system the cell values! (ncols * nrows of them) In in computer graphics we store the corner coordinates ((ncols + 1) * (nrows + 1) of them) an index, 4 indices for every quad specify the coordinates groupings (or at least material-properties), what quads belong to which objects the coordinate system (hopefully) It’s the same for a triangular mesh. the corner coordinates an index, 3 indices for every triangle groupings, what triangles belong to which objects the coordinate system (hopefully) And lines are the end point coordinates of each line segment (or edge) an index, 2 indices for every segment groupings, what line segments belong to which objects (features) the coordinate system (hopefully) 3.5 A raster is a mesh (implicitly) The simplest kind of mesh is a basic raster. Consider the matrix from above. m &lt;- matrix(c(seq(0, 0.5, length = 5), seq(0.375, 0, length = 4)), 3) On its own this matrix has absolutely nothing to do with spatial data, it is literally a collection of 9 numeric values in a given order, and by the magic of programming we’ve nominated a shape of 3x3. We can’t help but think about this shape spatially however, but there’s a problem. Does each element occupy space or should we consider them to be infinitesimal locations? R provides either interpretation (to simplify this story we nominate locations for the rows and columns explicitly). When considered as an image, each matrix element occupies a certain space in width and height, but when considered as a point set the numbers simply float at the given locations. Which is correct? (Spoiler: Both are correct, it simply depends what we are doing.) x &lt;- seq(1, nrow(m)) - 0.5 y &lt;- seq(1, ncol(m)) - 0.5 image(x, y, m, col = colpal()) text(expand.grid(x, y), lab = m[]) The raster package defaults to the image interpretation and helpfully assumes the values are nominally at the centre points as shown above. We have to nominate the extent or we end up in 0,1 range, we also have to invert the order of the values because raster counts from the top of the page and R’s matrix uses column-major order. library(raster) (r &lt;- raster(t(m[, ncol(m):1]), xmn = 0, xmx =ncol(m), ymn = 0, ymx = nrow(m))) ## class : RasterLayer ## dimensions : 3, 3, 9 (nrow, ncol, ncell) ## resolution : 1, 1 (x, y) ## extent : 0, 3, 0, 3 (xmin, xmax, ymin, ymax) ## crs : NA ## source : memory ## names : layer ## values : 0, 0.5 (min, max) R’s image and rasters in general are so efficient because they only store this minimal amount of information: the actual data values, and the extent and dimensions of the space they occur in. If we had to store the centre coordinate of every cell, or worse the corner coordinates then the data storage goes up dramatically. Every software that deals well with these kinds of data has to treat these coordinates as implicit. We can easily expand the centre coordinates. xyz &lt;- as.data.frame(r, xy = TRUE) head(xyz) ## x y layer ## 1 0.5 2.5 0.250 ## 2 1.5 2.5 0.125 ## 3 2.5 2.5 0.000 ## 4 0.5 1.5 0.375 ## 5 1.5 1.5 0.500 ## 6 2.5 1.5 0.375 tail(xyz) ## x y layer ## 4 0.5 1.5 0.375 ## 5 1.5 1.5 0.500 ## 6 2.5 1.5 0.375 ## 7 0.5 0.5 0.000 ## 8 1.5 0.5 0.125 ## 9 2.5 0.5 0.250 but to expand the corners we have to jump through some hoops and even then we get every instance of the corners, not only for each cell but to explicitly close the cell as a polygon. as(as(raster::rasterToPolygons(r), &quot;SpatialLinesDataFrame&quot;), &quot;SpatialPointsDataFrame&quot;) ## class : SpatialPointsDataFrame ## features : 45 ## extent : 0, 3, 0, 3 (xmin, xmax, ymin, ymax) ## crs : NA ## variables : 4 ## names : layer, Lines.NR, Lines.ID, Line.NR ## min values : 0, 1, 1, 1 ## max values : 0.5, 9, 9, 1 The polygon version of the raster, converted to points has 45 coordinates in it, although there are only 16 unique coordinates at the corners, which is where mesh3d comes in. 3.6 Summary Topology and geometry are independently dimensional Meshes include a matrix of vertices and a matrix of indices In mesh-terms rasters and polygons aren’t so different "],
["the-mesh3d-format.html", "Chapter 4 The mesh3d format 4.1 Quads 4.2 Triangles 4.3 3D polygons 4.4 rgl miscellanea", " Chapter 4 The mesh3d format Rgl is the OpenGL package in R. A classic computer graphics data model called mesh3d, it’s not widely used but is very powerful. You can visualize a mesh3d model with shade3d(), all the aesthetics, material properties, geometry and topology can be attached to the model itself as data. It supports two kinds of primitives quads and triangles. load(&quot;geo-comp-graphics.Rdata&quot;) 4.1 Quads Quads are a funny case, usually carried by two triangles (at least implicitly) but they are an important computer graphics element. Previously, we created a raster with effectively the following code. m &lt;- matrix(c(seq(0, 0.5, length = 5), seq(0.375, 0, length = 4)), 3) x &lt;- seq(1, nrow(m)) - 0.5 y &lt;- seq(1, ncol(m)) - 0.5 rast &lt;- raster::raster(list(x = x, y = y, z = m)) If we convert that to a quadmesh, the result has vertices (vb) and primitives (ib). library(quadmesh) qm &lt;- quadmesh(rast) str(qm) ## List of 8 ## $ vb : num [1:4, 1:16] 0 3 0.312 1 1 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:4] &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;1&quot; ## .. ..$ : NULL ## $ ib : int [1:4, 1:9] 1 2 6 5 2 3 7 6 3 4 ... ## $ primitivetype : chr &quot;quad&quot; ## $ material : list() ## $ normals : NULL ## $ texcoords : NULL ## $ raster_metadata:List of 7 ## ..$ xmn : num 0 ## ..$ xmx : num 3 ## ..$ ymn : num 0 ## ..$ ymx : num 3 ## ..$ ncols: int 3 ## ..$ nrows: int 3 ## ..$ crs : chr &quot;+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0&quot; ## $ crs : chr &quot;+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0&quot; ## - attr(*, &quot;class&quot;)= chr [1:3] &quot;quadmesh&quot; &quot;mesh3d&quot; &quot;shape3d&quot; The structure is vb, the coordinates of the mesh - these are the actual corner coordinates from the input raster. image(rast, col = colpal()) op &lt;- par(xpd = NA) text(t(qm$vb), lab = 1:ncol(qm$vb)) par(op) Notice how these are unique coordinates, there’s no simple relationship between the cell and its value and its four corners. This is because they are shared between neighbouring cells. The relationship is stored in the ib array, this has four rows one for each corner of each cell. There are 9 cells and each has four coordinates from the shared vertex pool. The cells are defined in the order they occur in raster. qm$ib ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## [1,] 1 2 3 5 6 7 9 10 11 ## [2,] 2 3 4 6 7 8 10 11 12 ## [3,] 6 7 8 10 11 12 14 15 16 ## [4,] 5 6 7 9 10 11 13 14 15 It works directly with rgl function, and can be used in more raw form. They key point in these plots is that with the exact same 3D geometry, we have the choice of how each primitive is styled. The colour may be a constant every where, or it may vary continuously everywhere between vertices. A final choice is that the colour is constant within a primitive. No R 2D plot can easily do the continuous texture styling. This also applies to other kinds of textures, later we will apply an image texture to primitives. library(rgl) #clear3d() shade3d(qm, col = &quot;firebrick&quot;) rglwidget(reuse = FALSE) clear3d() quads3d(t(qm$vb)[qm$ib,], col = c(&quot;firebrick&quot;, &quot;dodgerblue&quot;)[qm$ib %% 2 + 1]) rglwidget() clear3d() quads3d(t(qm$vb)[qm$ib,], col = rep(c(&quot;firebrick&quot;, &quot;dodgerblue&quot;), each = 4)) rglwidget() The situation for triangles is much the same, but we have it for the triangle index rather than ib for the quad index. In both cases the geometry is in the vb matrix. Models can have both quads and triangles, using the same set of vertices. 4.2 Triangles Triangles aren’t so readily created, although it is easy to convert a quadmesh version of a raster into triangles. For polygons, we need specialist code. There are two algorithm types: ear-clipping (or ear-cutting) near-Delaunay methods The mesh_polys object is create from the two_polys simple features layer using ear-clipping. This is a very simple algorithm, it chooses one corner of the polygon and clips off a triangle at the next vertex, then proceeds around the boundary - the decido package on CRAN uses the Mapbox library earcut to do this. library(sf) plot(two_polys, reset = FALSE) polygon(t(mesh_polys$vb[, rbind(mesh_polys$it, NA)])) The delaunay_polys object is created from two_polys using the in-development anglr package, on Github only - anglr uses the RTriangle package from CRAN to do this. All edges in the polygons are fed to the algorithm which creates all constrained triangles, then this mesh of triangles is processed to determine which polygon (or hole) each belongs to. With RTriangle we can also specify properties like maximum triangle area, or “conform to Delaunay criterion”. (This is why we always call polygon triangulation near-Delaunay …). This mesh is both Delaunay-conforming and applying a maximum triangle area, so extra vertices have been added that weren’t in the original polygons. plot(two_polys, reset = FALSE) polygon(t(delaunay_polys$vb[, rbind(delaunay_polys$it, NA)])) 4.3 3D polygons If we don’t have triangles (or quads), we can’t plot surfaces or polygons in 3D at all. clear3d() shade3d(mesh_polys) rglwidget() But, unless we modify the material properties of the surface, or update the geometry in the 3rd dimension we cannot tell the difference between these different mesh polygons. clear3d() shade3d(delaunay_polys) rglwidget() Let’s push the Delaunay version up in Z and add some noise. clear3d() delaunay_polys$vb[3,] &lt;- 0 delaunay_polys$vb[3,] &lt;- delaunay_polys$vb[3,] + runif(ncol(delaunay_polys$vb), 1, 1.5) wire3d(mesh_polys, col = &quot;grey&quot;) wire3d(delaunay_polys) rglwidget() The primary means to create this format from a raster is for 3D plotting, but because we have access to the coordinate directly it provides other uses. We can transform the coordinates (i.e. a map projection) or manipulate them and augment the Z value (for example) in flexible ways. (The usual way of driving rgl grid surfaces is rgl.surface but this is limited to the centre-point interpretation only - more than the x, y, z list interface as image() is, i.e. it can take an individual x,y pair for every cell, but it cannot properly represent the cell-as-area as image can. For this we need to use shade3d, and actual meshd3d types in rgl). 4.4 rgl miscellanea Most examples around use rgl.surface, but I am less familiar with that. The thing3d() are the higher-level functions in rgl, and the rgl.thing() functions are lower-level (recommended not to mix them in usage). rayshader in particular, has extremely compelling outputs, but it uses the lower level rgl.surface and doesn’t maintain the geographic coordinates, so I see it mostly as a texture-generator (but watch its development!). rgl.surface can take X and Y matrices, so you can trivially reproject these data and wrap them around a sphere - I only learnt this recently. WATCH OUT The single most confusing thing I found with mesh3d was homogeneous coordinates. This is a fourth value on each vertex, making it X, Y, Z, H and because it’s stored transpose, the ib and the vb matrices have the same number of rows (4). The H loosely corresponds to “zoom”, for our purposes set H = 1. (If set to 0 no data will be visible, and a package of mine had this bug until last week.) "],
["transforming-spatial-data-to-3d-forms.html", "Chapter 5 Transforming spatial data to 3D forms 5.1 Algorithms 5.2 raster 5.3 vector 5.4 Image textures 5.5 Triangles or quads from geospatial 5.6 Various other 3D tools in R", " Chapter 5 Transforming spatial data to 3D forms What tools exist to convert data to meshes in R? What forms of mesh data are available? The key package is rgl, the OpenGL package for R. This tends to be very low level, but has improved helpers and is becoming easier to use. The key functions are plot3d(), lines3d() and points3d() and these are used just like the 2D base funtions in R (with the ‘3d’ on the end). For polygons we first need to create triangles, and then use triangle3d(). For rasters we can create triangles or quads, and use quads3d(). There is also a mesh type object, mesh3d to store data with material properties. To plot mesh3d we use the shade3d() function. 5.1 Algorithms Converting points to 3D is really trivial, we only need the X-Y-Z coordinates, and we can set properties directly on them. Converting lines is also relatively easy, but here we might use a path model, sequential lists of coordinates that imply a connected line, or a segments model where every single individual line segment is specified separately. The segment model is really a mesh, because we have the opportunity to store every coordinate just once and refer to segments by their index. Converting polygons is much harder, and there are multiple ways to do it. The main division is by near-Delaunay triangulation, or by ear-cutting algorithms. near-Delaunay - high quality triangulations, suitable for surface modelling ear-cutting - low quality triangulation, suitable for flat surfaces The main tools available for geospatial data: quadmesh (on CRAN) - convert any raster to mesh3d quads, optionally with image textures anglr (not on CRAN) - convert any sp, sf lines or polygons to mesh3d triangles The rgl package has ear-cutting in triangulate3d(). The sfdct package (via RTriangle) has near-Delaunay in ct_triangulate() The decido package has ear-cutting in earcut(). Converting raster data is available in various ways. rgl::surface3d(), this is analogous to the old base image() function that can take x, y, z = matrix quadmesh::quadmesh(), converts raster, matrix, some stars to mesh3d rayshader determines elevation colouring from a matrix, and has many plotting helpers, and the best looking 3D plots and animations 5.2 raster A straightforward way to convert a raster layer to rgl mesh3d (cell values are Z-coordinate) is quadmesh. library(quadmesh) qmesh &lt;- quadmesh(anyRasterDEM, texture = anyRasterRGB) rgl::shade3d(qmesh) 5.3 vector Lines, and polygons in spatial classes can be converted using the anglr package. plot3d() will create the rgl plot and return a mesh3d() object as.mesh3d() will convert the object directly (very much in-development) The approach to converting polygons to mesh uses the functions TRI() or DEL() both produce triangulations, one with ear-cutting and one with “constrained Delaunay” methods. These aren’t ready for general use, so as.mesh3d() and plot3d() are the recommended ways to use the tools for now. 5.4 Image textures Image-textures is a very powerful way to map imagery onto a surface, the surface can be created from a raster or polygons, and can use quad or triangle primitives. The concept of texturing has some abstract details to it, but amounts to defining the 0,1 , 0,1 pixel index of the image on the vertices of the mesh. These are defined as $texcoords on the mesh3d object. Consider a simplified volcano data set as a quadmesh. library(raster) vsimpler &lt;- volcano[seq(1, nrow(volcano), by = 4), seq(1, ncol(volcano), by = 4)] vraster &lt;- raster(list(x = 1:nrow(vsimpler), y = 1:ncol(vsimpler), z = vsimpler), crs = NA) image(vraster) logo &lt;- brick(system.file(&quot;external/rlogo.grd&quot;, package=&quot;raster&quot;)) ## our logo belongs in the middle of volcano (obviously) logo &lt;- setExtent(logo, extent(9, 16, 7, 13)) projection(logo) &lt;- NA plotRGB(logo, add = TRUE) ## from the perspective of the mesh, the image will go where we set the texture ## coordinates as 0, 1, 0, 1 in the index space of the image itself segments(c(9, 16, 16, 16), c(6, 6, 7, 13), c(9, 16, 17, 17), c(7, 7, 7, 13)) text(9, 6, &quot;0&quot;, pos = 1) text(16, 6, &quot;1&quot;, pos = 1) text(17, 13, &quot;1&quot;, pos = 4) text(17, 7, &quot;0&quot;, pos = 4) The 2D plot above can be emulated in 3D with quad textures, the resolution of the image and the surface can be completely different. vtexture &lt;- quadmesh::quadmesh(vraster, texture = logo) ## writing texture image to /rdsi/PRIVATE/raad/dev/__tmp_mike/Rtmpgk9Vtw/file8f7179b9402.png rgl::clear3d(); rgl::shade3d(vtexture, specular = &quot;black&quot;); rgl::aspect3d(1, 1, .2); rgl::rglwidget(reuse = FALSE) This section requires a Mapbox API key to run from scratch - and can’t be shared directly, so it will simply be illustrated. loc &lt;- cbind(7 + 37.5/60, 51 + 57.6/60) buffer &lt;- 9000 library(ceramic) munster_elev &lt;- cc_elevation(loc, buffer, zoom = 12) munster_imag &lt;- cc_location(loc, buffer, zoom = 14) The process is a little complicated, but the key is that the elevation raster provides a space in which to map other data too. In this case the raster is in Mercator, and the image is as well. Under the hood we have to map the spatial part of the image into 0, 1, 0, 1 space of a PNG image, but in the final event we get a scene where real-world data may be added directly. munster_qmesh &lt;- quadmesh::quadmesh(munster_elev, texture = munster_imag) rgl::shade3d(munster_qmesh, lit = FALSE); rgl::aspect3d(1, 1, .05) ## more exact location of THIS building merc &lt;- sf::sf_project(cbind(7.59551, 51.96922), from = &quot;+init=epsg:4326&quot;, to = raster::projection(munster_elev)) rgl::lines3d(cbind(merc[c(1, 1), ], matrix(c(0, 1000)))) 5.5 Triangles or quads from geospatial This is my work-in-progress approach to meshing any polygon data structure with raster elevation. This is pseudo code but a real example is used with the North Carolina counties data set in the examples. ## devtools::install_github(&quot;hypertidy/anglr&quot;) ## devtools::install_github(&quot;hypertidy/silicate&quot;) library(anglr) triangles &lt;- copy_down(TRI(anySFpolygon), anyRasterDEM) mesh &lt;- plot3d(triangles) 5.6 Various other 3D tools in R rgl::triangulate and decido::earcut will triangulate polygons with holes but only suitable for plane-filling, because ugly triangles, no control over size and shape. RTriangle::triangulate (and sfdct::ct_triangulate) do high-quality “near-Delaunay” triangulations quadmesh::quadmesh() to create rgl-ready mesh3d from a raster cubeview::cubeView() does very compelling interactive raster-cube visualization mapdeck::mapdeck() a 3D viewer using Uber’s deck.gl deckgl package, another package using deck.gl threejs - 3D visualization with the ‘three.js’ library rayshader - very compelling 3D visualization and animation from matrix height map tylermorganwall/rayrender - general 3D scene creation, animation Rvcg package on CRAN has a number of mesh-processing and visualization tools hypertidy/silicate, hypertidy/anglr - these are evolving together short workshop on using A-Frame Virtual Reality with geospatial data: https://github.com/MilesMcBain/gis_vs_web3D coolbutuseless/threed - transformations on 3D objects "],
["examples-and-exercises.html", "Chapter 6 Examples and exercises 6.1 Exercise 1 6.2 Exercise 2 6.3 Exercise 3 6.4 Examples 6.5 Try with own data", " Chapter 6 Examples and exercises library(rgl) library(raster) library(quadmesh) library(anglr) library(silicate) In each chunk below consider each 3D scene as being a “fresh start”. Use rgl::clear3d() to ensure there is no existing data in a scene. If using RStudio Server (rstudio.cloud, binder, etc.) then calling rglwidget() is required to capture the 3D plot (or changes to it) and refresh the htmlwidget viewer. 6.1 Exercise 1 Why are the vertex and index matrices stored in transpose form? ## create a very simple raster m &lt;- matrix(c(seq(0, 0.5, length = 5), seq(0.375, 0, length = 4)), 3) x &lt;- seq(1, nrow(m)) - 0.5 y &lt;- seq(1, ncol(m)) - 0.5 rast &lt;- raster::raster(list(x = x, y = y, z = m)) qm &lt;- quadmesh::quadmesh(rast) str(qm) ## List of 8 ## $ vb : num [1:4, 1:16] 0 3 0.312 1 1 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:4] &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;1&quot; ## .. ..$ : NULL ## $ ib : int [1:4, 1:9] 1 2 6 5 2 3 7 6 3 4 ... ## $ primitivetype : chr &quot;quad&quot; ## $ material : list() ## $ normals : NULL ## $ texcoords : NULL ## $ raster_metadata:List of 7 ## ..$ xmn : num 0 ## ..$ xmx : num 3 ## ..$ ymn : num 0 ## ..$ ymx : num 3 ## ..$ ncols: int 3 ## ..$ nrows: int 3 ## ..$ crs : chr &quot;+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0&quot; ## $ crs : chr &quot;+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0&quot; ## - attr(*, &quot;class&quot;)= chr [1:3] &quot;quadmesh&quot; &quot;mesh3d&quot; &quot;shape3d&quot; 6.1.1 EX 1 ANSWER EX1 SOLUTION So that sets of coordinates and primitive-indexes are stored contiguously in memory. I think this matches more native implementations in other languages. Code to plot quads directly in rgl looks like this: quads3d(t(qm$vb[, qm$ib])) We can use to to advantage in 2D, for a quick check of our intepretation. plot(t(qm$vb[1:2, ])) pp &lt;- qm$vb[1:2, rbind(qm$ib, NA)] ## put an NA after every set of 4 coordinates polygon(t(pp)) 6.2 Exercise 2 Run this code Think about what is wrong with the scene. What can we do about the ugly plot? library(quadmesh) qm1 &lt;- quadmesh(crop(worldll, etopo)) qm1$vb[3, ] &lt;- raster::extract(etopo, t(qm1$vb[1:2, ])) library(rgl) clear3d() shade3d(qm1, col = &quot;white&quot;) 6.2.1 EX 2 ANSWER EX2 SOLUTION We need to modify the aspect ratio, because we are plotting coordinates in degrees against elevation in metres. There’s no one right answer, getting a sensible aspect ratio will depend on the data in the scene. aspect3d(1, 1, 0.05) ## run this only if you are in a web rstudio rglwidget() 6.3 Exercise 3 Run this code Can you explain why we multiply the Etopo2 terrain elevation by 20? What are alternatives we could use? qm2 &lt;- qm1 qm2$vb[3, ] &lt;- qm2$vb[3, ] * 20 ## the llh2xyz() function converts lon-lat-height to ## spherical geocentric XYZ coordinates qm2$vb[1:3, ] &lt;- t(llh2xyz(t(qm2$vb[1:3, ]))) rgl.clear() shade3d(qm2, col = &quot;white&quot;, specular = &quot;black&quot;) aspect3d(1, 1, 0.5) ## run this only if you are in a web rstudio rglwidget() 6.4 Examples 6.4.1 Quadmesh NOTE: The quadmesh::quadmesh() function converts a raster object directly to rgl mesh3d object. Set up, see https://mdsumner.github.io/geo-comp-graphics-oghub/getting-set-up.html library(raster) library(quadmesh) library(anglr) library(silicate) The volcano is a built-in matrix height-map. rvolcano &lt;- raster(volcano) library(quadmesh) qm_volcano &lt;- quadmesh(rvolcano) library(rgl) clear3d() shade3d(qm_volcano, col = &quot;grey&quot;); aspect3d(1, 1, 0.25) The etopo data set is a partial world topography (Etopo2). We only need to convert it to quadmesh. data(&quot;etopo&quot;, package = &quot;quadmesh&quot;) qm_etopo &lt;- quadmesh(crop(etopo, extent(80, 160, -50, 10))) qm_etopo$material$col &lt;- colourvalues::colour_values(qm_etopo$vb[3, qm_etopo$ib]) shade3d(qm_etopo); aspect3d(1, 1, .2) 6.4.2 Polygon triangulation NOTE: the functions DEL() and TRI() will triangulate polygon layers into an currently-experimental form, using the development packages anglr and silicate. The plot3d() function converts these Polygon-triangulation vesion of the North Carolina data set - we add Z values (copy_down()) to the triangles from an elevation topography raster. Copy-down for a raster value considers Z a continuous measure, so each feature is connected by shared vertices to neighbours. library(sf) north_carolina &lt;- read_sf(system.file(&quot;gpkg/nc.gpkg&quot;, package = &quot;sf&quot;)) north_carolina &lt;- st_transform(north_carolina, &quot;+proj=laea +lon_0=-80 +lat_0=35 +datum=WGS84&quot;) library(silicate) library(anglr) data(&quot;gebco1&quot;, package = &quot;anglr&quot;) mesh_nc &lt;- DEL(north_carolina, max_area = 1e9) ## copy down values from a raster (continuous measure) mesh_nc &lt;- copy_down(mesh_nc, gebco1) ## plot it anglr:::plot3d.TRI(mesh_nc); aspect3d(1, 1, .2) Copy-down for a polygon value considers Z a discrete measure, so each feature is separated. ## another example, copy feature attributes (discrete measure) mesh_bir &lt;- copy_down(TRI(north_carolina, max_area = 1e9), &quot;BIR79&quot;) plot3d(mesh_bir); aspect3d(1, 1, .2) 6.4.3 Coordinate systems and textures Copy an RBG image onto 3D terrain, the resolution and projection of the terrain raster and the image raster can be different, also we can change the coordinate system of the terrain itself - the texture coordinates are an independent mapping for the RGB image and still work. # Create and texture a 3D mesh in R from a variety of spatial data sources (e.g. # Shapefile + digital elevation model + satellite raster). library(quadmesh) library(raster) bm_url &lt;- &quot;https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg&quot; bm_file &lt;- basename(bm_url) if (!file.exists(bm_file)) download.file(bm_url, bm_file) ## read in RGB image and set geographical extent and projection bm_rgb &lt;- raster::setExtent(raster::brick(bm_file), raster::extent(-180, 180, -90, 90)) projection(bm_rgb) &lt;- &quot;+proj=longlat +datum=WGS84&quot; ## consider reducing resolution of the image - it can be a good idea to ## reduce heavily, check it works, then try with higher resolution (smaller `fact`) ## or avoid the aggregate step altogether bm_rgb &lt;- raster::aggregate(bm_rgb, fact = 2) south &lt;- quadmesh(etopo, texture = bm_rgb) south$vb[3, ] &lt;- south$vb[3, ] * 20 south$vb[1:3, ] &lt;- t(llh2xyz(t(south$vb[1:3, ]))) shade3d(south) aspect3d(1, 1, 0.5) 6.5 Try with own data Convert rasters to mesh3d with quadmesh() Convert polygons to mesh3d with as.mesh3d() (using anglr package) Plot mesh3d or spatial objects with plot3d() "]
]
